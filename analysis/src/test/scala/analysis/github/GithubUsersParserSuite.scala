package gitrate.analysis.github

import gitrate.utils.TestUtils
import org.scalatest.{fixture, Outcome}

class GithubUsersParserSuite extends fixture.WordSpec with TestUtils {

  import play.api.libs.json.JsValue

  "GithubUsersParser" can {

    "filter GitHub API output" should {

      "ignore users with invalid type (e.g. organization)" in { fixture =>
        assert(fixture containsUser "target-user")
        assert(!(fixture containsUser "organization-user"))
      }

      "not ignore target repos" in { fixture =>
        assert(fixture.userHasRepo("target-user", "repo-pinned1"))
        assert(fixture.userHasRepo("target-user", "repo-pinned2"))
      }

      "ignore too young repos" in { fixture =>
        assert(!fixture.userHasRepo("target-user", "YOUNG-repo"))
        assert(!fixture.userHasRepo("hermityang", "YOUNG-repo-2"))
      }

      "allow only repos with commits mostly made by the user" ignore { fixture =>
        assert(!fixture.userHasRepo("target-user", "repo-with-mostly-commits-by-OTHERS"))
      }

      "ignore forked repos" ignore { fixture =>
        assert(!fixture.userHasRepo("target-user", "forked-repo"))
      }

      "ignore repos with primary language we don't support" ignore { fixture =>
        assert(!fixture.userHasRepo("target-user", "repo-with-UNKNOWN-as-primary"))
      }

      "returns found repos and then pinned repos as priority" ignore { fixture =>
        assert(
          fixture.reposOfUser("target-user").take(4) === Seq("repo-found",
                                                             "repo-pinned",
                                                             "repo-by-owner",
                                                             "repo-with-javascript-as-primary"))
      }

      "ignore users with too little number of target repositories" ignore { fixture =>
        assert(!(fixture containsUser "user-with-a-single-repo"))
      }

      "ignore fake and autogenerated emails" ignore { fixture =>
        val target = "target-user"
        val nonTarget = "user-with-bad-email"
        assert(fixture containsUser target)
        assert(fixture containsUser nonTarget)
        fixture.findUser(target).foreach(user => assert(user.email === Some("valid-mail@domain.com")))
        fixture.findUser(nonTarget).foreach(user => assert(user.email.isEmpty))
      }

      "repos should not contain duplicates" ignore { fixture =>
        val uniqueIds = fixture.repos.map(repo => repo.idBase64).hasOnlyUniqueItems
        val uniqueNames = fixture.repos.map(repo => repo.name).hasOnlyUniqueItems
        assert(uniqueIds && uniqueNames)
      }

      "users should not contain duplicates" ignore { fixture =>
        val uniqueIds = fixture.users.map(user => user.id).hasOnlyUniqueItems
        val uniqueLogins = fixture.users.map(user => user.login).hasOnlyUniqueItems
        assert(uniqueIds && uniqueLogins)
      }
    }

    "package object" should {

      "parse and filter user IDs" in { fixture =>
        val user = "MDQ6VXNlcjY1MDI0MDE="
        val organization = "MDEyOk9yZ2FuaXphdGlvbjI1MDE0Mjcy"
        val invalid = "invalid"
        assert(parseAndFilterUserId(user) === Some("6502401"))
        assert(parseAndFilterUserId(organization).isEmpty)
        assert(parseAndFilterUserId(invalid).isEmpty)
      }

    }

    // TODO: separate module?
    /*"fetch additional info" should {
      "detect services used" in {
        assert(
          fixture.servicesOf("alopatindev", "qdevicemonitor") === Seq("travis-ci.org", "appveyor.com")
          fixture.servicesOf("alopatindev", "find-telegram-bot") === Seq(
            "travis-ci.org",
            "codecov.io",
            "codeclimate.com",
            "semaphoreci.com",
            "bithound.io",
            "versioneye.com",
            "david-dm.org",
            "dependencyci.com",
            "snyk.io",
            "npmjs.com"
          ))
      }
    }

    // TODO: separate module per language?
    "external containerized program" should {
      "download repo" in {
        fixture.downloadRepo("alopatindev", "find-telegram-bot")
        eventually {
          assert(fixture.fileExists("/tmp/gitrate-analyzer/alopatindev/find-telegram-bot/.gitignore"))
        }
      }
      "detect dependencies" in {
        fixture.downloadRepo("alopatindev", "find-telegram-bot")
        eventually {
          assert(fixture.rawDependenciesOf("alopatindev", "find-telegram-bot") === Seq("phantom", "telegraf", "winston", "bithound", "codecov", "eslint", "eslint-plugin-better", "eslint-plugin-mocha", "eslint-plugin-private-props", "eslint-plugin-promise", "istanbul", "mocha", "mocha-logger", "nodemon"))
        }
      }
      "rename dependencies and ignore aliases" in {
        assert(fixture.dependenciesOf("alopatindev", "find-telegram-bot") contains "PhantomJS")
        assert(!(fixture.dependenciesOf("alopatindev", "find-telegram-bot") contains "phantomjs"))
      }
      "cleanup temporary files when done" in {
        fixture.cleanup("alopatindev", "find-telegram-bot")
        eventually {
          assert(!fixture.fileExists("/tmp/gitrate-analyzer/alopatindev/find-telegram-bot/.gitignore"))
        }
      }
    }

    // TODO: separate module?
    "static analysis" should {
      "apply analysis of supported languages used in the repo" in { ??? }
      "run on the same machine and container as wget" in { ??? }
      "return bad grades when code is bad" in { ??? }
      "return good grades when code is good" in { ??? }
      //"return code coverage grade" in { ??? }
      "return all supported grade types" in { ??? }
      //"ignore code that can't compile" in { ??? } // it can fail because of dependencies we don't have
      "ignore users with too low total grade" in { ??? }
    }*/

  }

  override def withFixture(test: OneArgTest): Outcome = {
    val reposParser = new GithubReposParser(minRepoAgeDays = 2 * 30,
                                            minOwnerToAllCommitsRatio = 0.7f,
                                            supportedLanguages = Seq("JavaScript", "Python"),
                                            minTargetRepos = 2)
    val githubParser = new GithubParser(reposParser)
    val response: JsValue = loadJsonResource("/GithubResultFilterFixture.json")
    val input: JsValue = (response \ "data" \ "search").get
    val theFixture = FixtureParam(githubParser, input)
    try {
      withFixture(test.toNoArgTest(theFixture))
    } finally {}
  }

  case class FixtureParam(val githubParser: GithubParser, val input: JsValue) {
    val users: Seq[GithubUser] = githubParser.parseUsersAndRepos(input)

    def repos: Seq[GithubRepo] = users.flatMap(u => u.repos)

    def containsUser(login: String): Boolean = findUsers(login).isDefinedAt(0)

    def userHasRepo(login: String, repoName: String): Boolean = findRepos(login, repoName).isDefinedAt(0)

    def reposOfUser(login: String): Seq[String] =
      findUsers(login).flatMap(user => user.repos.map(repo => repo.name))

    def findUsers(login: String): Seq[GithubUser] = users.filter(_.login == login)

    def findUser(login: String): Option[GithubUser] = findUsers(login).headOption

    def findRepos(login: String, repoName: String): Seq[GithubRepo] =
      findUsers(login).flatMap(user => user.repos.filter(repo => repo.name == repoName))
  }

}
