package gitrate.analysis.github

import gitrate.utils.TestUtils

import org.scalatest.{fixture, Outcome}

class GithubUsersParserSuite extends fixture.WordSpec with TestUtils {

  "GithubUsersParser" can {

    "filter GitHub API output" should {
      "get all users" in { fixture =>
        assert(fixture.filter.users.take(3).map(_.login) === Seq())
      }
      "ignore users with invalid type (e.g. organization)" in { fixture =>
        assert(fixture.filter.user("target-user").isValid)
        assert(!fixture.filter.user("not-user").isValid)
      }
      "ignore too young repos" in { fixture =>
        assert(fixture.filter.user("target-user").repo("old-repo").isOld)
        assert(!fixture.filter.user("target-user").repo("young-repo").isOld)
      }
      "allow only repos with commits mostly made by the user" in { fixture =>
        assert(fixture.filter.user("target-user").repo("repo-with-mostly-commits-by-owner").hasMostlyCommitsByOwner)
        assert(!fixture.filter.user("target-user").repo("repo-with-mostly-commits-by-others").hasMostlyCommitsByOwner)
      }
      "ignore repos user doesn't own" in { fixture =>
        assert(fixture.filter.user("target-user").repo("repo-by-owner").userIsOwner)
        assert(!fixture.filter.user("target-user").repo("repo-by-others").userIsOwner)
      }
      "ignore repos with primary language we don't support" in { fixture =>
        assert(fixture.filter.user("target-user").repo("repo-with-javascript-as-primary").isLanguageSupported)
        assert(!fixture.filter.user("target-user").repo("repo-with-unknown-as-primary").isLanguageSupported)
      }
      "returns found repos and then pinned repos as priority" in { fixture =>
        assert(
          fixture.filter.user("target-user").targetRepos.take(4).map(_.name).toSeq === Seq(
            "repo-found",
            "repo-pinned",
            "repo-by-owner",
            "repo-with-javascript-as-primary"))
      }
      "ignore users with too little number of target repositories" in { fixture =>
        assert(fixture.filter.user("non-target-user").targetRepos.length === 2)
        assert(!fixture.filter.user("non-target-user").isTarget)
      }
      /* we already requesting with a limit?
      "limit number of target repositories" in { fixture =>
        assert(fixture.filter.users.forall(user => user.targetRepos.length <= 6))
      }*/
      "ignore fake and autogenerated emails" in { fixture =>
        assert(fixture.filter.user("target-user").email === Some("valid-mail@domain.com"))
        assert(fixture.filter.user("user-with-bad-email").email.isEmpty)
      }
    }

    // TODO: separate module?
    /*"fetch additional info" should {
      "detect services used" in {
        assert(
          fixture.servicesOf("alopatindev", "qdevicemonitor") === Seq("travis-ci.org", "appveyor.com")
          fixture.servicesOf("alopatindev", "find-telegram-bot") === Seq(
            "travis-ci.org",
            "codecov.io",
            "codeclimate.com",
            "semaphoreci.com",
            "bithound.io",
            "versioneye.com",
            "david-dm.org",
            "dependencyci.com",
            "snyk.io",
            "npmjs.com"
          ))
      }
    }

    // TODO: separate module per language?
    "external containerized program" should {
      "download repo" in {
        fixture.downloadRepo("alopatindev", "find-telegram-bot")
        eventually {
          assert(fixture.fileExists("/tmp/gitrate-analyzer/alopatindev/find-telegram-bot/.gitignore"))
        }
      }
      "detect dependencies" in {
        fixture.downloadRepo("alopatindev", "find-telegram-bot")
        eventually {
          assert(fixture.rawDependenciesOf("alopatindev", "find-telegram-bot") === Seq("phantom", "telegraf", "winston", "bithound", "codecov", "eslint", "eslint-plugin-better", "eslint-plugin-mocha", "eslint-plugin-private-props", "eslint-plugin-promise", "istanbul", "mocha", "mocha-logger", "nodemon"))
        }
      }
      "rename dependencies and ignore aliases" in {
        assert(fixture.dependenciesOf("alopatindev", "find-telegram-bot") contains "PhantomJS")
        assert(!(fixture.dependenciesOf("alopatindev", "find-telegram-bot") contains "phantomjs"))
      }
      "cleanup temporary files when done" in {
        fixture.cleanup("alopatindev", "find-telegram-bot")
        eventually {
          assert(!fixture.fileExists("/tmp/gitrate-analyzer/alopatindev/find-telegram-bot/.gitignore"))
        }
      }
    }

    // TODO: separate module?
    "static analysis" should {
      "apply analysis of supported languages used in the repo" in { ??? }
      "run on the same machine and container as wget" in { ??? }
      "return bad grades when code is bad" in { ??? }
      "return good grades when code is good" in { ??? }
      //"return code coverage grade" in { ??? }
      "return all supported grade types" in { ??? }
      //"ignore code that can't compile" in { ??? } // it can fail because of dependencies we don't have
      "ignore users with too low total grade" in { ??? }
    }*/

  }

  override def withFixture(test: OneArgTest): Outcome = {
    val theFixture = FixtureParam(
      GithubUsersParser(result, minRepoAgeDays, minOwnerToAllCommitsRatio, supportedLanguages, minTargetRepos))
    try {
      withFixture(test.toNoArgTest(theFixture))
    } finally {}
  }

  case class FixtureParam(val filter: GithubUsersParser)

  private val result = loadJsonResource("/GithubResultFilterFixture.json")
  private val minRepoAgeDays: Int = 2 * 30
  private val minOwnerToAllCommitsRatio: Float = 0.7f
  private val supportedLanguages: Seq[String] = Seq("JavaScript", "Python")
  private val minTargetRepos: Int = 4

}
